
---
title: "Micro-metrics, [Glen Waddell](https://glenwaddell.com)"
author: Boyoon Chang
date: "Winter 2020"
#date: "<br>`r format(Sys.time(), '%d %B %Y')`"
header-includes:
  - \usepackage{mathtools}
  - \DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
  - \usepackage{amssymb}
output: 
  html_document: 
    code_folding: hide
    theme: flatly
    highlight: tango
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r Setup, include = F}
options(htmltools.dir.version = FALSE)
library(pacman)
# p_load(broom, latex2exp, leaflet, ggplot2, ggthemes, viridis, dplyr, magrittr, knitr, parallel, rddtools, readxl, emoGG, dslabs, gapminder, extrafont, Ecdat, wooldridge, tidyverse, janitor, kableExtra, gridExtra, estimatr, data.tables)
p_load("data.table", "ggplot2", "collapse", "fixest")

```


```{r}
# Define pink color
red_pink <- "#e64173"
turquoise <- "#20B2AA"
orange <- "#FFA500"
red <- "#fb6107"
blue <- "#3b3b9a"
green <- "#8bb174"
grey_light <- "grey70"
grey_mid <- "grey50"
grey_dark <- "grey20"
purple <- "#6A5ACD"
slate <- "#314f4f"
# Dark slate grey: #314f4f
# Notes directory
dir_slides <- "~/Dropbox/Courses/"
# Knitr options
opts_chunk$set(
  comment = "#>",
  fig.align = "center",
  fig.height = 4,
  fig.width = 6,
  # dpi = 300,
  cache = T,
  warning = F,
  message = F)
# A blank theme for ggplot
theme_empty <- theme_bw() + theme(
  line = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text = element_blank(),
  plot.title = element_blank(),
  axis.title = element_blank(),
  plot.margin = structure(c(0, 0, -1, -1), unit = "lines", valid.unit = 3L, class = "unit"),
  legend.position = "none"
)
theme_simple <- theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  axis.text.x = element_text(size = 10),
  axis.text.y = element_text(size = 10),
  axis.ticks = element_blank(),
  plot.title = element_blank(),
  axis.title.x = element_text(angle = 0, vjust = 0.5),
  axis.title.y = element_text(angle = 90, vjust = 0.5),
  legend.position = "none",
  axis.line = element_line(color="black", size = .5)
)
```



# {.tabset .tabset-fade .tabset-pills}


## A6 - Event study

---

> Due date: 25 February 2021?

---

An event study can be described by the estimation of the model,
$$y_{it} = \alpha_i + \sum_{t~\ne~T-1}\beta_t~(T_{it}=1)+e_{it}~,$$
where $T_{it}=1$ captures the arrival of treatment (in period $T$). The sum is meant to imply that the omitted category is the period prior to the onset of treatment.

**Part 1.** Simulate a DGP in which treatment is imposed on a fraction of units in a panel. Adopting something like the DGP of A5 would be reasonable. Produce an event study figure that represents the effect of treatment on outcomes.



```{r}
## Step 0: load packages


## Step 1: Create a panel
### allocate individual id as well as time 

dgp_fun = function(ind_totalID = 6, 
                   pre_totalT = 5, 
                   post_totalT = 5, 
                   alpha = 10,
                   beta = 40){
  # setting the number of periods
  time = rep(1:(pre_totalT+post_totalT), each = ind_totalID)
  # setting the number of ids
  ind_ID = rep(1:ind_totalID, pre_totalT + post_totalT)
  # setting the number of observations
  n = 1:length(ind_ID)*length(time)
  # setting the error term 
  error = rnorm(n, 0, 1)
  # setting the treatment
  treat = sample(c(0,1), size = ind_totalID, replace=TRUE, prob=c(0.5, 0.5))

  # generating individual level variation (alpha)
  ## same level of variation between treated and control group
  alpha_noise = rnorm(ind_totalID, 0,1)
  ## no variation of slope across pre-treatment periods (parallel trend pre period)
  beta_noise_pre = rep(0, each=pre_totalT*ind_totalID)
  ## variation of slope across post-treatment period (non-parallel trend post period)
  beta_noise_post = rep(sapply(1:post_totalT, function(x){rnorm(1, 2*x, 1)}), each = ind_totalID)
  
  beta_noise = c(beta_noise_pre, beta_noise_post)
  DT = data.table(treat, n, pre_totalT, time, ind_ID, alpha, 
                  alpha_noise, beta, beta_noise, error)
  DT[, ':=' (alpha_ind = alpha + alpha_noise,
             beta_ind = beta + beta_noise), by = ind_ID][
        , y := alpha_ind + beta_ind*treat + error][
          , ':=' (upper = max(y), lower = min(y)), by=time]
  return(DT)
}


d = dgp_fun()

d$time = relevel(factor(d$time), ref="5")
est = feols(y ~ as.factor(time)*treat, data = d) 
est_sum = est %>% tidy() %>% filter(str_detect(term, coll(":treat")))
est_sum$time = as.numeric(str_sub(est_sum$term, 16, -7))
t_cv = qt(0.025, df = (max(d$n)-2), lower.tail = FALSE)
est_sum$ci_l = est_sum$estimate - t_cv*est_sum$std.error 
est_sum$ci_h = est_sum$estimate + t_cv*est_sum$std.error 
ggplot(est_sum, aes(x=factor(time), y = estimate)) + 
  geom_linerange(aes(ymin=ci_l, ymax=ci_h))+
  geom_pointrange(aes(ymin=ci_l, ymax=ci_h))+
  geom_errorbar(aes(ymin=ci_l, ymax=ci_h)) +
  xlab("Time") + ylab("Estimates") + ggtitle("Event Study with Treatment Effect Increasing over Time")



```

<br>


**Part 2:** Build into that DGP the potential for **(i)** non-parallel trends, **(ii)** parallel pre-treatment trends, with trends diverging in post treatment periods, **(iii)** an Ashenfelter dip, and **(iv)** a treatment that is anticipated (in a way that has units "responding" before it arrives. (_There are more violations, obviously, but these are a good set to start with. Add others if you are in an area that you think has a particular challenge._)

```{r}
dgp_fun2 = function(ind_totalID = 100, 
                    pre_totalT = 5, 
                    post_totalT = 5,
                    c_intercept = 0,
                    c_slope = 2,
                    t_slope = 4){
  # setting the number of periods
  time = rep(1:(pre_totalT+post_totalT), each = ind_totalID)
  post = (time > pre_totalT)
  # setting the number of ids
  ind_ID = rep(1:ind_totalID, pre_totalT + post_totalT)
  # setting the number of observations
  n = 1:length(time)
  # setting the error term 
  error = rnorm(n, 0, 5)
  # setting the treatment
  treat = sample(c(0,1), size = ind_totalID, replace=TRUE, prob=c(0.5, 0.5))
  # individual level
  alpha_noise_c = rnorm(ind_totalID, 0, 5)
  alpha_noise_t = rnorm(ind_totalID, 4, 5)
  alpha = ifelse(treat==0, alpha_noise_c, alpha_noise_t)
  # control outcome
  y_c = c_intercept + alpha_noise_c + c_slope * time +error
  # treated outcome
  # y_t = c_intercept + alpha_noise_t + ifelse(time<=5, 5+c_slope*time, 10+t_slope*time ) + error
  # counterfactual outcome
  ## parallel trend
  y_cf= c_intercept + 5 + alpha_noise_t + c_slope * time + error
  ## non-parallel trend
  y_t1 = c_intercept + 5 + alpha_noise_t + error
  ## diverging trend
  y_t2 = c_intercept + alpha_noise_t + ifelse(time<=5, 5+c_slope*time, 10+t_slope*time ) + error
  ## Aschenfelter dip
  y_t3 = c_intercept + alpha_noise_t + ifelse(time<=5, ifelse(time == 5, 0, 5+c_slope*time), 10+t_slope*time )+error
  ## Anticipated treatment
  y_t4 = c_intercept + alpha_noise_t + ifelse(time<=5, -c_slope*time, 10+t_slope*time )+error
  ## y 
  y = c_intercept + alpha_noise_c*(1-treat) + c_slope * time *(1-treat) + 
      alpha_noise_t*treat + 
      treat*(1-post)*(5+c_slope*time)+treat*post*(10+t_slope*time)+error
  
  DT = data.table(time, post, ind_ID, n, error, treat, alpha, alpha_noise_c, alpha_noise_t,
                  y_c, y, 
                  y_cf, 
                  y_t1,
                  y_t2,
                  y_t3,
                  y_t4
                  )
  
  return(DT)
}
a =dgp_fun2(ind_totalID = 100, 
            pre_totalT = 5, 
            post_totalT = 5,
            c_intercept = 0,
            c_slope = 5,
            t_slope = 10)
b = a %>% pivot_longer(y_t1:y_t4, names_to = "case", values_to = "y_t")

ggplot() + 
  geom_jitter(data = b[b$treat==1,], 
              aes(x = time, y = y_t, color = case))  +
  stat_summary(data = b[b$treat==1,],
              aes(x= time, y = y_t, color = case),fun=mean, geom="line", alpha = 1,size = 1) + 
  geom_jitter(data = b[b$treat==0,], 
              aes(x = time, y = y_c), color = "steelblue", alpha = 0.2, size = 1)+
  stat_summary(data = b[b$treat==0,], aes(x=time, y = y_c),color = "steelblue",
               fun=mean, geom="line", alpha = 1,size = 1)+
  stat_summary(data = b[b$treat==1,], 
               aes(x= time, y = y_cf), color = "black", fun=mean, geom="line", linetype = "dotted", alpha = 1,size = 1) +
  geom_vline(xintercept = 6, linetype="dashed")+
  ylab("y")+
  xlab("Time") +
  scale_color_viridis_d()
```





```{r}
model_sim= function(ind_totalID = 100, 
                    pre_totalT = 5, 
                    post_totalT = 5,
                    c_intercept = 0,
                    c_slope = 5,
                    t_slope = 10){
  a = dgp_fun2(ind_totalID , 
              pre_totalT , 
              post_totalT ,
              c_intercept ,
              c_slope,
              t_slope )
  t_est0 = (mean(a$y_t[a$post == 1]) - mean(a$y_c[a$post == 1])) -
            (mean(a$y_cf[a$post == 1]) - mean(a$y_c[a$post == 1]))
  ## 1
  t_est1 = (mean(a$y_t[a$post == 1]) - mean(a$y_c[a$post == 1])) -
    (mean(a$y_cf1[a$post == 1]) - mean(a$y_c[a$post == 1]))
  ## 2
  t_est2 = (mean(a$y_t[a$post == 1]) - mean(a$y_c[a$post == 1])) -
    (mean(a$y_cf2[a$post == 1]) - mean(a$y_c[a$post == 1]))
  ## 3
  t_est3 = (mean(a$y_t[a$post == 1]) - mean(a$y_c[a$post == 1])) -
    (mean(a$y_t3[a$post == 0]) - mean(a$y_c[a$post == 0]))
  ## 4
  t_est4 =(mean(a$y_t[a$post == 1]) - mean(a$y_c[a$post == 1])) -
    (mean(a$y_t4[a$post == 0]) - mean(a$y_c[a$post == 0]))
  return(c(t_est0, t_est1, t_est2, t_est3, t_est4))
}

n_sims=1000
sim_data = replicate(n_sims, model_sim(ind_totalID = 100, 
                                       pre_totalT = 5, 
                                       post_totalT = 5,
                                       c_intercept = 0,
                                       c_slope = 5,
                                       t_slope = 10))
sim_data = as.data.frame(t(sim_data))
colnames(sim_data) = c("t_est0", "t_est1", "t_est2", "t_est3", "t_est4")
sim_data$id = seq(1:nrow(sim_data))

sim_data = sim_data %>% pivot_longer(t_est0:t_est4, names_to="case", values_to = "estimates")

# ggplot(sim_data[sim_data$case!="t_est0",]) + 
#   geom_density(aes(estimates, fill = case)) + 
#   scale_fill_viridis_d() 
TEffect_did = mean(sim_data[sim_data$case == "t_est0",]$estimates)
TEffect_actual1 = mean(sim_data[sim_data$case == "t_est1",]$estimates)
TEffect_actual2 = mean(sim_data[sim_data$case == "t_est2",]$estimates)
TEffect_actual3 = mean(sim_data[sim_data$case == "t_est3",]$estimates)
TEffect_actual4 = mean(sim_data[sim_data$case == "t_est4",]$estimates)
```


```{r}
# 1
plot_fun = function(i) {
  p = ggplot() + 
  geom_jitter(data = b[b$treat==1,], 
              aes(x = time, y = y_t), color = "darkred", alpha = 0.2, size = 1)+
  stat_summary(data = b[b$treat==1,], 
               aes(x= time, y = y_t), color = "darkred",fun=mean, geom="line", alpha = 1,size = 1) +
  geom_jitter(data = b[b$treat==1 & b$counter_factual == i,], 
              aes(x= time, y = y_cf, color = counter_factual),alpha = 0.2, size = 1) +
  scale_color_viridis_d()+
  stat_summary(data = b[b$treat==1 & b$counter_factual == i,], 
               aes(x=time, y = y_cf, color = counter_factual),fun=mean, geom="line", alpha = 1,size = 1) +
  geom_jitter(data = b[b$treat==0,], 
              aes(x = time, y = y_c), color = "steelblue", alpha = 0.2, size = 1)+
  stat_summary(data = b[b$treat==0,], 
               aes(x=time, y = y_c),color = "steelblue",fun=mean, geom="line", alpha = 1,size = 1)+
  geom_vline(xintercept = 6, linetype="dashed")+
  ylab("y")+
  xlab("Time")+
  stat_summary(data = b[b$treat==1 & b$counter_factual == "y_cf",], 
               aes(x= time, y = y_cf), 
               color = "black", fun=mean, geom="line", linetype = "dotted", alpha = 1,size = 1) 

  return(p)
}
plot_list=list("y_cf1", "y_cf2")
lapply(plot_list, function(x){plot_fun(x)})
Results = as.data.frame(cbind(TEffect_did = TEffect_did, rbind(TEffect_actual1, TEffect_actual2)))
Results %<>% mutate(Biasedness = ifelse(Results[,1]<Results[,2], "Downward Biased", "Upward Biased"))
rownames(Results) = c("case1", "case2")
colnames(Results) = c("TEffect_did", "True_TEffect", "Biasedness")
kable(Results, format = "html")
```

```{r}
plot_fun2 = function(i){
  p = ggplot() + geom_jitter(data = b[b$treat==1,], 
              aes(x = time, y = y_t), color = "darkred", alpha = 0.2, size = 1)+
  stat_summary(data = b[b$treat==1,],
              aes(x= time, y = y_t),color = "darkred",fun=mean, geom="line", alpha = 1,size = 1) +
  geom_jitter(data = b[b$treat==1 & b$treated_outcome == i,], 
              aes(x= time, y = y_t.other, color = treated_outcome),alpha = 0.2, size = 1) +
  stat_summary(data = b[b$treat==1 & b$treated_outcome == i,], 
               aes(x=time, y = y_t.other, color = treated_outcome),
               fun=mean, geom="line", alpha = 1,size = 1) +
  geom_jitter(data = b[b$treat==0,], 
              aes(x = time, y = y_c), color = "steelblue", alpha = 0.2, size = 1)+
  stat_summary(data = b[b$treat==0,], aes(x=time, y = y_c),color = "steelblue",
               fun=mean, geom="line", alpha = 1,size = 1)+
  geom_vline(xintercept = 6, linetype="dashed")+
  ylab("y")+
  xlab("Time") +
  scale_color_viridis_d()+
  stat_summary(data = b[b$treat==1 & b$counter_factual == "y_cf",], 
               aes(x= time, y = y_cf), 
               color = "black", fun=mean, geom="line", linetype = "dotted", alpha = 1,size = 1) 
  return(p)
}
plot_list2=list("y_t3", "y_t4")
lapply(plot_list2, function(x){plot_fun2(x)})
Results = as.data.frame(cbind(TEffect_did = TEffect_did, rbind(TEffect_actual3, TEffect_actual4)))
Results %<>% mutate(Biasedness = ifelse(Results[,1]<Results[,2], "Downward Biased", "Upward Biased"))
rownames(Results) = c("case3", "case4")
colnames(Results) = c("TEffect_did", "True_TEffect", "Biasedness")
kable(Results, format = "html")

```



```{r}
a$time = relevel(factor(a$time), ref="5")
est = feols(y ~ as.factor(time)*treat, data = a) 
est_sum = est %>% tidy() %>% filter(str_detect(term, coll(":treat")))
est_sum$time = as.numeric(str_sub(est_sum$term, 16, -7))
t_cv = qt(0.025, df = (max(a$n)-2), lower.tail = FALSE)
est_sum$ci_l = est_sum$estimate - t_cv*est_sum$std.error 
est_sum$ci_h = est_sum$estimate + t_cv*est_sum$std.error 
ggplot(est_sum, aes(x=factor(time), y = estimate)) + 
  geom_linerange(aes(ymin=ci_l, ymax=ci_h))+
  geom_pointrange(aes(ymin=ci_l, ymax=ci_h))+
  geom_errorbar(aes(ymin=ci_l, ymax=ci_h)) + 
  xlab("Time") 

# it feels like y should be formulated differently 

```




---

