
---
title: "Micro-metrics, [Glen Waddell](https://glenwaddell.com)"
author: Boyoon Chang
date: "Winter 2020"
#date: "<br>`r format(Sys.time(), '%d %B %Y')`"
header-includes:
  - \usepackage{mathtools}
  - \DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
  - \usepackage{amssymb}
output: 
  html_document: 
    code_folding: hide
    theme: flatly
    highlight: tango
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r Setup, include = F}
options(htmltools.dir.version = FALSE)
library(pacman)
# p_load(broom, latex2exp, leaflet, ggplot2, ggthemes, viridis, dplyr, magrittr, knitr, parallel, rddtools, readxl, emoGG, dslabs, gapminder, extrafont, Ecdat, wooldridge, tidyverse, janitor, kableExtra, gridExtra, estimatr, data.tables)
p_load("data.table", "ggplot2", "collapse", "fixest", "knitr", dplyr, broom, magrittr, stringr, tidyverse)

```


```{r include=FALSE}
# Define pink color
red_pink <- "#e64173"
turquoise <- "#20B2AA"
orange <- "#FFA500"
red <- "#fb6107"
blue <- "#3b3b9a"
green <- "#8bb174"
grey_light <- "grey70"
grey_mid <- "grey50"
grey_dark <- "grey20"
purple <- "#6A5ACD"
slate <- "#314f4f"
# Dark slate grey: #314f4f
# Notes directory
dir_slides <- "~/Dropbox/Courses/"
# Knitr options
opts_chunk$set(
  comment = "#>",
  fig.align = "center",
  fig.height = 4,
  fig.width = 6,
  # dpi = 300,
  cache = T,
  warning = F,
  message = F)
# A blank theme for ggplot
theme_empty <- theme_bw() + theme(
  line = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text = element_blank(),
  plot.title = element_blank(),
  axis.title = element_blank(),
  plot.margin = structure(c(0, 0, -1, -1), unit = "lines", valid.unit = 3L, class = "unit"),
  legend.position = "none"
)
theme_simple <- theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  axis.text.x = element_text(size = 10),
  axis.text.y = element_text(size = 10),
  axis.ticks = element_blank(),
  plot.title = element_blank(),
  axis.title.x = element_text(angle = 0, vjust = 0.5),
  axis.title.y = element_text(angle = 90, vjust = 0.5),
  legend.position = "none",
  axis.line = element_line(color="black", size = .5)
)
```



# {.tabset .tabset-fade .tabset-pills}


## A6 - Event study

---

> Due date: 25 February 2021?

---

An event study can be described by the estimation of the model,
$$y_{it} = \alpha_i + \sum_{t~\ne~T-1}\beta_t~(T_{it}=1)+e_{it}~,$$
where $T_{it}=1$ captures the arrival of treatment (in period $T$). The sum is meant to imply that the omitted category is the period prior to the onset of treatment.

**Part 1.** Simulate a DGP in which treatment is imposed on a fraction of units in a panel. Adopting something like the DGP of A5 would be reasonable. Produce an event study figure that represents the effect of treatment on outcomes.



```{r}
## Step 0: load packages


## Step 1: Create a panel
### allocate individual id as well as time 

dgp_fun = function(ind_totalID = 6, 
                   pre_totalT = 5, 
                   post_totalT = 5, 
                   alpha = 10,
                   beta = 40){
  # setting the number of periods
  time = rep(1:(pre_totalT+post_totalT), each = ind_totalID)
  # setting the number of ids
  ind_ID = rep(1:ind_totalID, pre_totalT + post_totalT)
  # setting the number of observations
  n = 1:length(ind_ID)*length(time)
  # setting the error term 
  error = rnorm(n, 0, 1)
  # setting the treatment
  treat = sample(c(0,1), size = ind_totalID, replace=TRUE, prob=c(0.5, 0.5))

  # generating individual level variation (alpha)
  ## same level of variation between treated and control group
  alpha_noise = rnorm(ind_totalID, 0,1)
  ## no variation of slope across pre-treatment periods (parallel trend pre period)
  beta_noise_pre = rep(0, each=pre_totalT*ind_totalID)
  ## variation of slope across post-treatment period (non-parallel trend post period)
  beta_noise_post = rep(sapply(1:post_totalT, function(x){rnorm(1, 2*x, 1)}), each = ind_totalID)
  
  beta_noise = c(beta_noise_pre, beta_noise_post)
  DT = data.table(treat, n, pre_totalT, time, ind_ID, alpha, 
                  alpha_noise, beta, beta_noise, error)
  DT[, ':=' (alpha_ind = alpha + alpha_noise,
             beta_ind = beta + beta_noise), by = ind_ID][
        , y := alpha_ind + beta_ind*treat + error][
          , ':=' (upper = max(y), lower = min(y)), by=time]
  return(DT)
}


d = dgp_fun()

d$time = relevel(factor(d$time), ref="5")
est = feols(y ~ as.factor(time)*treat, data = d) 
est_sum = est %>% tidy() %>% filter(str_detect(term, coll(":treat")))
est_sum$time = as.numeric(str_sub(est_sum$term, 16, -7))
t_cv = qt(0.025, df = (max(d$n)-2), lower.tail = FALSE)
est_sum$ci_l = est_sum$estimate - t_cv*est_sum$std.error 
est_sum$ci_h = est_sum$estimate + t_cv*est_sum$std.error 
ggplot(est_sum, aes(x=factor(time), y = estimate)) + 
  geom_linerange(aes(ymin=ci_l, ymax=ci_h))+
  geom_pointrange(aes(ymin=ci_l, ymax=ci_h))+
  geom_errorbar(aes(ymin=ci_l, ymax=ci_h)) +
  xlab("Time") + ylab("Estimates") + ggtitle("Event Study with Treatment Effect Increasing over Time")



```

<br>


**Part 2:** Build into that DGP the potential for **(i)** non-parallel trends, **(ii)** parallel pre-treatment trends, with trends diverging in post treatment periods, **(iii)** an Ashenfelter dip, and **(iv)** a treatment that is anticipated (in a way that has units "responding" before it arrives. (_There are more violations, obviously, but these are a good set to start with. Add others if you are in an area that you think has a particular challenge._)

```{r}
dgp_fun2 = function(ind_totalID = 100, 
                    pre_totalT = 5, 
                    post_totalT = 5,
                    c_intercept = 0,
                    c_slope = 2,
                    t_slope = 4){
  # setting the number of periods
  time = rep(1:(pre_totalT+post_totalT), each = ind_totalID)
  post = (time > pre_totalT)
  # setting the number of ids
  ind_ID = rep(1:ind_totalID, pre_totalT + post_totalT)
  # setting the number of observations
  n = 1:length(time)
  # setting the error term 
  error = rnorm(n, 0, 5)
  # setting the treatment
  treat = sample(c(0,1), size = ind_totalID, replace=TRUE, prob=c(0.5, 0.5))
  # individual level
  alpha_noise_c = rnorm(ind_totalID, 0, 5)
  alpha_noise_t = rnorm(ind_totalID, 4, 5)
  alpha = ifelse(treat==0, alpha_noise_c, alpha_noise_t)
  # control outcome
  y_c = c_intercept + alpha_noise_c + c_slope * time +error
  # treated outcome
  # y_t = c_intercept + alpha_noise_t + ifelse(time<=5, 5+c_slope*time, 10+t_slope*time ) + error
  # counterfactual outcome
  ## parallel trend
  y_cf= c_intercept + 5 + alpha_noise_t + c_slope * time + error
  ## non-parallel trend
  y_t1 = c_intercept + 5 + alpha_noise_t + error
  ## diverging trend
  y_t2 = c_intercept + alpha_noise_t + ifelse(time<=5, 5+c_slope*time, 10+t_slope*time ) + error
  ## Aschenfelter dip
  y_t3 = c_intercept + alpha_noise_t + ifelse(time<=5, ifelse(time == 5, 0, 5+c_slope*time), 10+t_slope*time )+error
  ## Anticipated treatment
  y_t4 = c_intercept + alpha_noise_t + ifelse(time<=5, -c_slope*time, 10+t_slope*time )+error
  ## y 
  y = c_intercept + alpha_noise_c*(1-treat) + c_slope * time *(1-treat) + 
      alpha_noise_t*treat + 
      treat*(1-post)*(5+c_slope*time)+treat*post*(10+t_slope*time)+error
  y1 = treat*y_t1 + (1-treat)*y_c
  y2 = treat*y_t2 + (1-treat)*y_c
  y3 = treat*y_t3 + (1-treat)*y_c
  y4 = treat*y_t4 + (1-treat)*y_c
  
  DT = data.table(time, post, ind_ID, n, error, treat, alpha, alpha_noise_c, alpha_noise_t,
                  y_c, 
                  y,
                  y1,
                  y2,
                  y3,
                  y4,
                  y_cf, 
                  y_t1,
                  y_t2,
                  y_t3,
                  y_t4
                  )
  
  return(DT)
}
a =dgp_fun2(ind_totalID = 100, 
            pre_totalT = 5, 
            post_totalT = 5,
            c_intercept = 0,
            c_slope = 5,
            t_slope = 10)
b = a %>% pivot_longer(y_t1:y_t4, names_to = "case", values_to = "y_t")

ggplot() + 
  geom_jitter(data = b[b$treat==1,], 
              aes(x = time, y = y_t, color = case), alpha=0.2)  +
  stat_summary(data = b[b$treat==1,],
              aes(x= time, y = y_t, color = case),fun=mean, geom="line", alpha = 1,size = 1) + 
  geom_jitter(data = b[b$treat==0,], 
              aes(x = time, y = y_c), color = "steelblue", alpha = 0.2, size = 1)+
  stat_summary(data = b[b$treat==0,], aes(x=time, y = y_c),color = "steelblue",
               fun=mean, geom="line", alpha = 1,size = 1)+
  stat_summary(data = b[b$treat==1,], 
               aes(x= time, y = y_cf), color = "black", fun=mean, geom="line", linetype = "dotted", alpha = 1,size = 1) +
  geom_vline(xintercept = 6, linetype="dashed")+
  ylab("y")+
  xlab("Time") +
  scale_color_viridis_d()
```





```{r}
rep =  rep(seq(1:4), each = 9)
model_sim= function(ind_totalID = 100, 
                    pre_totalT = 5, 
                    post_totalT = 5,
                    c_intercept = 0,
                    c_slope = 5,
                    t_slope = 10){
  a = dgp_fun2(ind_totalID , 
              pre_totalT , 
              post_totalT ,
              c_intercept ,
              c_slope,
              t_slope )
  a$time = relevel(factor(a$time), ref="5")
  est1 = feols(y1~as.factor(time)*treat, data = a) %>% 
    tidy() %>% filter(str_detect(term, coll(":treat")))
  est2 = feols(y2~as.factor(time)*treat, data = a) %>% 
    tidy() %>% filter(str_detect(term, coll(":treat")))
  est3 = feols(y3~as.factor(time)*treat, data = a) %>%
    tidy() %>% filter(str_detect(term, coll(":treat")))
  est4 = feols(y4~as.factor(time)*treat, data = a) %>% 
    tidy() %>% filter(str_detect(term, coll(":treat")))
  ests = cbind(rbind(est1, est2, est3, est4), rep)
  return(ests)
}
sim_data = model_sim()
# a$time = relevel(factor(d$time), ref="5")
# est = feols(y ~ as.factor(time)*treat, data = d) 
# est_sum = est %>% tidy() %>% filter(str_detect(term, coll(":treat"))) 
sim_data$time = as.numeric(str_sub(sim_data$term, 16, -7))
t_cv = qt(0.025, df = (max(d$n)-2), lower.tail = FALSE)
sim_data$ci_l = sim_data$estimate - t_cv*sim_data$std.error 
sim_data$ci_h = sim_data$estimate + t_cv*sim_data$std.error 
plot_fun=function(i) {p = ggplot(sim_data %>% filter(rep==i), aes(x=factor(time), y = estimate)) + 
  geom_linerange(aes(ymin=ci_l, ymax=ci_h))+
  geom_pointrange(aes(ymin=ci_l, ymax=ci_h))+
  geom_errorbar(aes(ymin=ci_l, ymax=ci_h)) +
  xlab("Time") + ylab("Estimates") + ggtitle("Event Study with Treatment Effect Increasing over Time") +
  ylim(-30, 120)
   return(p)
}
lapply(1:4, plot_fun)
```



---

